{$CLEO .s}
{$INCLUDE_ONCE ../cleo_tester.inc}

script_name 'SDK@31'
test("SDK: CLEO_ReadParamsFormatted", tests)
terminate_this_custom_script

function tests
    it("should handle malformed format string", test1)
    it("should handle correct lowercase input", test2)
    it("should handle correct uppercase input", test3)
    it("should handle extra arguments", test4)
    it("should handle specifier and argument type mismatch", test5)
    return

    function test1(buf: int)
        ExpectError(@mock1_incomplete)
        ExpectError(@mock2_missing)
        ExpectError(@mock3_unknown)
        ExpectError(@mock7_too_few_args) // too few arguments is an error
    end

    function test2(buf: int)
        int formatted = GetFormattedString(@mock4_valid)
        assert_eqs(formatted, "valid 42")
        formatted = GetFormattedString(@mock5_mix)
        assert_eqs(formatted, "str test num 123 float 3.14")
        formatted = GetFormattedString(@mock9_pct)
        assert_eqs(formatted, "percent %")
        formatted = GetFormattedString(@mock10_long)
        assert_eqs(formatted, "large string This is a very long string that should fit into the buffer without any issues.")
        formatted = GetFormattedString(@mock11_ptr)
        assert_eqs(formatted, "pointer 12345678")
        formatted = GetFormattedString(@mock14_valid_str_ptr)
        assert_eqs(formatted, "str BUSTED")
    end

    function test3(buf: int)
        int formatted = GetFormattedStringUppercase(@mock4_valid)
        assert_eqs(formatted, "VALID 42")
        formatted = GetFormattedStringUppercase(@mock5_mix)
        assert_eqs(formatted, "STR test NUM 123 FLOAT 3.14") // test is an argument, no formatting
        formatted = GetFormattedStringUppercase(@mock9_pct)
        assert_eqs(formatted, "PERCENT %")
        formatted = GetFormattedStringUppercase(@mock10_long)
        assert_eqs(formatted, "LARGE STRING This is a very long string that should fit into the buffer without any issues.") // This is ... is an argument, no formatting
        formatted = GetFormattedStringUppercase(@mock11_ptr)
        assert_eqs(formatted, "POINTER 12345678")
        formatted = GetFormattedStringUppercase(@mock14_valid_str_ptr)
        assert_eqs(formatted, "STR BUSTED")
    end


    function test4(buf: int)
        // too many arguments is a warning

        int formatted = GetFormattedString(@mock6_extra)
        assert_eqs(formatted, "extra args 1")

        formatted = GetFormattedString(@mock8_empty)
        assert_eqs(formatted, "")
    end

   
    function test5(buf: int)
        int formatted = GetFormattedString(@mock12_str_address)
        assert_prefix(formatted, "num ", false) // the rest is the random string pointer
        formatted = GetFormattedStringUppercase(@mock12_str_address)
        assert_prefix(formatted, "NUM ", false) // the rest is the random string pointer
        
        formatted = GetFormattedString(@mock13_invalid_str_ptr)
        assert_eqs(formatted, "num (INVALID_STR)")
        formatted = GetFormattedStringUppercase(@mock13_invalid_str_ptr)
        assert_eqs(formatted, "NUM (INVALID_STR)")
        
        formatted = GetFormattedString(@mock15_float_decimal)
        assert_eqs(formatted, "num 1110048768") // 1110048768 is 0x422A0000 or 42.5
        formatted = GetFormattedStringUppercase(@mock15_float_decimal)
        assert_eqs(formatted, "NUM 1110048768") // 1110048768 is 0x422A0000 or 42.5
    end

end

:mock1_incomplete
trace {format} "incomplete %0.0" {args} 0x41

:mock2_missing
trace {format} "missing %" {args} 0x41

:mock3_unknown
trace "unknown %y" {args} 0x41

:mock4_valid
trace "valid %d" {args} 42

:mock5_mix
trace "str %s num %d float %.2f" {args} "test" 123 3.14159

:mock6_extra
trace "extra args %d" {args} 1 2 3 4 5

:mock7_too_few_args
trace "not enough args %d %s %f" {args} 10

:mock8_empty
trace "" {args} 0

:mock9_pct
trace "percent %%"

:mock10_long
trace "large string %s" {args} "This is a very long string that should fit into the buffer without any issues."

:mock11_ptr
trace "pointer %p" {args} 0x12345678

:mock12_str_address
trace "num %d" {args} 'str'

:mock13_invalid_str_ptr
trace "num %s" {args} 42

:mock14_valid_str_ptr
trace "str %s" {args} 0x0085987C // address of BUSTED string

:mock15_float_decimal
trace "num %d" {args} 42.5


function GetFormattedString(label: int): int
    int code = get_label_pointer label
    code += 2 // skip opcode id
    int script = CRunningScript_new(code)
    int string_arg = CLEO_ReadStringOpcodeParam(script)
    int res = CLEO_ReadParamsFormatted(script, string_arg, 0, 0)
    free_memory {address} script
    return res
end

function GetFormattedStringUppercase(label: int): int
    int code = get_label_pointer label
    code += 2 // skip opcode id
    int script = CRunningScript_new(code)
    int string_arg = CLEO_ReadStringOpcodeParam(script)
    MakeUpperCase(string_arg)
    int res = CLEO_ReadParamsFormatted(script, string_arg, 0, 0)
    free_memory {address} script
    return res
    
    function MakeUpperCase<cdecl, 0x718710>(src: string)
end

function ExpectError(label: int)
    int formatted = GetFormattedString(label)
    assert_eq(formatted, 0)
end

function CRunningScript_new(ip: int): int
    int struct = allocate_memory {size} 0xE0
    write_memory_with_offset {address} struct {offset} 0x10 {size} 4 {value} ip // baseIp
    write_memory_with_offset {address} struct {offset} 0x14 {size} 4 {value} ip // currentIp
    return struct
end

/// Reads format string and arguments from the script and returns a formatted string or nullptr if error
function CLEO_ReadParamsFormatted(script: int, format: int, buf: int, buf_size: int): int
    if ReadParamsFormatted fn = GetCLEOSDK("_CLEO_ReadParamsFormatted@16")
    then
        int result = fn(script, format, buf, buf_size)
        return result
    end
    return 0

    function ReadParamsFormatted<stdcall>(script: int, format: int, buf: int, buf_size: int): int
end

// Reads a string argument from script and returns a pointer (always null-terminated)
function CLEO_ReadStringOpcodeParam(script: int): int
    if ReadStringOpcodeParam fn = GetCLEOSDK("_CLEO_ReadStringOpcodeParam@12")
    then
        int result = fn(script, 0, 0)
        return result
    end
    return 0

    function ReadStringOpcodeParam<stdcall>(script: int, buf: int, buf_size: int): int
end

/// Returns a pointer to a function exported from CLEO.asi
function GetCLEOSDK(name: string): optional int
    if int cleo = load_dynamic_library {fileName} "CLEO.asi"
    then
        if int func = get_dynamic_library_procedure {procName} name cleo
        then
            free_dynamic_library cleo
            return func
        else
            free_dynamic_library cleo
            return
        end
    end
end